import path from 'path'
import endent from 'endent'
import redent from 'redent'
import { Node, Signature, Type } from 'ts-morph'
import { OpleParser } from './parser'
import { warn } from './warnings'
import {
  findReferencedTypes,
  isExternalModule,
  mergeIntoSet,
  printImport,
  printJSDocs,
} from './common'

/**
 * Generate the module that calls `defineBackend`
 * on the frontend.
 */
export function printClientModule(parser: OpleParser, backendUrl: string) {
  const { collections } = parser
  const referencedTypes = new Set<Node>()

  const collectionTypes = Object.values(collections).map(coll => {
    let type = `${coll.name}: OpleCollection`
    if (coll.type) {
      findReferencedTypes(coll.type, referencedTypes)
      type += '<' + coll.type.getText() + '>'
    }
    return type
  })

  const functions = Object.values(parser.functions)
  const functionTypes = functions.map(fun => {
    mergeIntoSet(referencedTypes, fun.referencedTypes)
    return fun.signatures.map(sig => printSignature(sig, fun.name))
  })

  const signals = Object.values(parser.signals)
  const signalTypes = signals.map(signal => {
    mergeIntoSet(referencedTypes, signal.referencedTypes)
    return signal.signature
  })

  const opleClientId = '@ople/client'
  const imports: Record<string, string[]> = {
    [opleClientId]: ['defineBackend', 'OpleProtocol'],
  }
  if (collectionTypes.length) {
    imports[opleClientId].push('OpleCollection')
  }
  if (signalTypes.length) {
    imports[opleClientId].push('OpleListener')
  }
  const typeNames = new Set<string>()
  const dedupedTypes: Record<string, Node[]> = {}
  const backendModulePath = path.join(parser.root, 'backend/db.ts')
  referencedTypes.forEach(typeNode => {
    const file = typeNode.getSourceFile()
    if (file.getFilePath() == backendModulePath) {
      return // Ignore generated types.
    }

    // Types from internal modules are recursively crawled.
    if (!isExternalModule(file, parser.root)) {
      findReferencedTypes(typeNode, referencedTypes)
    }

    if (!Node.isNamedNode(typeNode)) {
      return
    }

    const name = typeNode.getName()
    if (name == 'OpleDocument') {
      return // "OpleDocument<T>" is transformed into "T"
    }
    // These types are globally declared in ople.init.ts
    // but not on the client-side.
    if (/^Ople(Ref|Time|Date)$/.test(name)) {
      imports[opleClientId].push(name)
      return
    }

    const moduleInfo = parser.dependencies.get(file)
    if (moduleInfo) {
      if (moduleInfo.id == '@ople/backend') {
        return
      }
      const vars = (imports[moduleInfo.id] ??= [])
      if (vars.includes(name)) {
        return
      }
      if (!typeNames.has(name)) {
        typeNames.add(name)
        vars.push(name)
      }
    } else {
      let typeNodes = dedupedTypes[name]
      if (!typeNodes) {
        typeNodes = dedupedTypes[name] = []
        typeNames.add(name)
      } else if (
        Node.isTypeAliasDeclaration(typeNode) ||
        Node.isTypeAliasDeclaration(typeNodes[0])
      ) {
        warn(typeNode, `Type skipped. Name already taken: "${name}"`)
        return
      }
      typeNodes.push(typeNode)
    }
  })
  const printedTypes = Object.keys(dedupedTypes).map(name => {
    const typeNodes = dedupedTypes[name]
    const lines: string[] = []
    if (typeNodes.length > 1) {
      let postlude = ''
      for (const typeNode of typeNodes) {
        if (Node.isInterfaceDeclaration(typeNode)) {
          lines.length || lines.push(`export interface ${name} {`)
          const sourceFile = typeNode.getSourceFile()
          for (const prop of typeNode.getMembers()) {
            if (sourceFile == prop.getSourceFile()) {
              lines.push(redent(printJSDocs(prop) + prop.getText(), 2))
            }
          }
        } else {
          postlude += (postlude ? '\n' : '') + typeNode.getFullText()
        }
      }
      lines.length && lines.push('}')
      postlude && lines.push(postlude)
    } else {
      lines[0] = typeNodes[0].getFullText()
    }
    return redent(lines.join('\n'), 0).trim()
  })

  return endent`
    /**
     * DO NOT EDIT THIS DIRECTLY!
     * Generated by @ople/codegen
     */
    ${Object.entries(imports).map(printImport).join('\n')}

    interface Collections {
      ${collectionTypes.join('\n')}
    }

    interface Functions {
      ${functionTypes.join('\n')}
    }

    interface Signals {
      ${signalTypes.join('\n')}
    }

    const backend = defineBackend<Collections, Functions, Signals>({
      protocol: OpleProtocol.ws,
      url: "${backendUrl}",
    })

    export default backend

    const { functions, signals } = backend

    ${functions
      .map(({ name }) => `export const ${name} = functions.${name}`)
      .join('\n')}

    ${signals
      .map(({ name }) => `export const ${name} = signals.${name}`)
      .join('\n')}

    ${printedTypes.join('\n\n')}
  `
}

function printSignature(sign: Signature, name: string) {
  const decl = sign.getDeclaration()
  if (!Node.isParameteredNode(decl)) {
    throw Error('Signature must be from a parametered node')
  }

  const params = decl.getParameters().map(printNode)
  const typeParams = sign.getTypeParameters().map(printType)
  const returnType = printType(decl.getReturnType()).replace(
    /\bOpleDocument<(.+?)>/g,
    '$1'
  )

  return (
    printJSDocs(decl) +
    name +
    (typeParams.length ? `<${typeParams.join(', ')}>` : ``) +
    `(${params.join(', ')}): Promise<${returnType}>`
  )
}

function printNode(node: Node) {
  return node.getText(true)
}

function printType(type: Type) {
  return type.getText().replace(/\bimport\("[^"]+"\)\./g, '')
}
