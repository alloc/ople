import endent from 'endent'
import redent from 'redent'
import { ts, Node, Signature, Type } from 'ts-morph'
import { OpleParser } from './parser'
import { findReferencedTypes } from './common'
import { warn } from './warnings'

const mergeIntoSet = <T>(
  into: Set<T>,
  from: { forEach(cb: (value: T) => void): void }
) => from.forEach(value => into.add(value))

/**
 * Generate the module that calls `defineBackend`
 * on the frontend.
 */
export function printClientModule(parser: OpleParser, backendUrl: string) {
  const { collections } = parser
  const referencedTypes = new Set<Node>()

  const collectionTypes = Object.values(collections).map(coll => {
    let type = `${coll.name}: OpleCollection`
    if (coll.type) {
      findReferencedTypes(coll.type, referencedTypes)
      type += '<' + coll.type.getText() + '>'
    }
    return type
  })

  const functions = Object.values(parser.functions)
  const functionTypes = functions.map(fun => {
    mergeIntoSet(referencedTypes, fun.referencedTypes)
    return fun.signatures.map(sig => printSignature(sig, fun.name))
  })

  const signals = Object.values(parser.signals)
  const signalTypes = signals.map(signal => {
    mergeIntoSet(referencedTypes, signal.referencedTypes)
    return signal.signature
  })

  const opleClientId = '@ople/client'
  const imports: Record<string, string[]> = {
    [opleClientId]: ['defineBackend', 'OpleProtocol'],
  }
  if (collectionTypes.length) {
    imports[opleClientId].push('OpleCollection')
  }
  if (signalTypes.length) {
    imports[opleClientId].push('OpleListener')
  }
  const typeNames = new Set<string>()
  const printedTypes: string[] = []
  referencedTypes.forEach(type => {
    findReferencedTypes(type, referencedTypes)
    if (!Node.isNamedNode(type)) {
      return
    }
    const name = type.getName()
    if (/^Ople(Ref|Time|Date)$/.test(name)) {
      imports[opleClientId].push(name)
      return
    }
    const modulePath = type.getSourceFile().getFilePath()
    const moduleInfo = parser.projectDependencies.get(modulePath)
    if (moduleInfo) {
      const vars = (imports[moduleInfo.id] ??= [])
      if (!vars.includes(name)) {
        if (typeNames.has(name)) {
          warn(type, `Type skipped. Name already taken: "${name}"`)
        } else {
          vars.push(name)
        }
      }
    } else if (typeNames.has(name)) {
      warn(type, `Type skipped. Name already taken: "${name}"`)
    } else {
      typeNames.add(name)
      printedTypes.push(redent(type.getFullText(), 0).trim())
    }
  })

  return endent`
    /**
     * DO NOT EDIT THIS DIRECTLY!
     * Generated by @ople/codegen
     */
    ${Object.entries(imports)
      .map(([source, vars]) => `import { ${vars.join(', ')} } from "${source}"`)
      .join('\n')}

    interface Collections {
      ${collectionTypes.join('\n')}
    }

    interface Functions {
      ${functionTypes.join('\n')}
    }

    interface Signals {
      ${signalTypes.join('\n')}
    }

    const backend = defineBackend<Collections, Functions, Signals>({
      protocol: OpleProtocol.ws,
      url: "${backendUrl}",
    })

    export default backend

    const { functions, signals } = backend

    ${functions
      .map(({ name }) => `export const ${name} = functions.${name}`)
      .join('\n')}

    ${signals
      .map(({ name }) => `export const ${name} = signals.${name}`)
      .join('\n')}

    ${printedTypes.join('\n\n')}
  `
}

function printSignature(sign: Signature, name: string) {
  const decl = sign.getDeclaration()
  if (!Node.isParameteredNode(decl)) {
    throw Error('Signature must be from a parametered node')
  }

  const getText = (node: Node | Type) =>
    node instanceof Type
      ? node.getText(decl, ts.TypeFormatFlags.UseFullyQualifiedType)
      : node.getText()

  const params = decl.getParameters().map(getText).join(', ')
  const returnType = getText(decl.getReturnType())
  const typeParams = sign.getTypeParameters().map(getText).join(', ')

  const [docs] = sign.getDocumentationComments()

  return (
    (docs ? `/**${docs.getText().replace(/(^|\n)/g, `\n * `)}\n */\n` : ``) +
    name +
    (typeParams.length ? `<${typeParams}>` : ``) +
    `(${params}): ${returnType}`
  )
}
