import endent from 'endent'
import redent from 'redent'
import { Node } from 'ts-morph'
import { OpleParser } from './parser'
import { findReferencedTypes, getDefinitions } from './common'

const mergeIntoSet = <T>(
  into: Set<T>,
  from: { forEach(cb: (value: T) => void): void }
) => from.forEach(value => into.add(value))

/**
 * Generate the module that calls `defineBackend`
 * on the frontend.
 */
export function printClientModule(parser: OpleParser) {
  const { functions, collections } = parser
  const referencedTypes = new Set<Node>()

  const collectionTypes = Object.values(collections).map(coll => {
    let type = `${coll.name}: OpleCollection`
    if (coll.type) {
      findReferencedTypes(coll.type, referencedTypes)
      type += '<' + coll.type.getText() + '>'
    }
    return type
  })

  const functionTypes = functions.map(fun => {
    mergeIntoSet(referencedTypes, fun.referencedTypes)
    return fun.signature
  })

  const signals = Object.values(parser.signals)
  const signalTypes = signals.map(signal => {
    mergeIntoSet(referencedTypes, signal.referencedTypes)
    return signal.signature
  })

  const opleClientId = '@ople/client'
  const imports: Record<string, string[]> = {
    [opleClientId]: ['defineBackend'],
  }
  if (collectionTypes.length) {
    imports[opleClientId].push('OpleCollection')
  }
  if (signalTypes.length) {
    imports[opleClientId].push('OpleListener')
  }
  const typeNames = new Set<string>()
  const printedTypes: string[] = []
  referencedTypes.forEach(type => {
    findReferencedTypes(type, referencedTypes)
    if (!Node.isNamedNode(type)) {
      return
    }
    const name = type.getName()
    if (/^Ople(Ref|Time|Date)$/.test(name)) {
      imports[opleClientId].push(name)
      return
    }
    const modulePath = type.getSourceFile().getFilePath()
    const moduleInfo = parser.projectDependencies.get(modulePath)
    if (moduleInfo) {
      const vars = (imports[moduleInfo.id] ??= [])
      if (!vars.includes(name)) {
        if (typeNames.has(name)) {
          // TODO: warn about naming conflict
        } else {
          vars.push(name)
        }
      }
    } else if (typeNames.has(name)) {
      // TODO: warn about naming conflict
    } else {
      typeNames.add(name)
      printedTypes.push(redent(type.getFullText(), 0).trim())
    }
  })

  return endent`
    /**
     * DO NOT EDIT THIS DIRECTLY!
     * Generated by @ople/codegen
     */
    ${Object.entries(imports)
      .map(([source, vars]) => `import { ${vars.join(', ')} } from "${source}"`)
      .join('\n')}

    interface Collections {
      ${collectionTypes.join('\n')}
    }

    interface Functions {
      ${functionTypes.join('\n')}
    }

    interface Signals {
      ${signalTypes.join('\n')}
    }

    const backend = defineBackend<Collections, Functions, Signals>()
    export default backend

    const { functions, signals } = backend

    ${functions
      .map(({ name }) => `export const ${name} = functions.${name}`)
      .join('\n')}

    ${signals
      .map(({ name }) => `export const ${name} = signals.${name}`)
      .join('\n')}

    ${printedTypes.join('\n\n')}
  `
}
