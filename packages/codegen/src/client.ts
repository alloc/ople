import path from 'path'
import endent from 'endent'
import redent from 'redent'
import {
  Node,
  ParameterDeclaration,
  ParameteredNode,
  Signature,
  Type,
} from 'ts-morph'
import { OpleParser } from './parser'
import { warn } from './warnings'
import {
  findReferencedTypes,
  getNameNode,
  isExternalModule,
  mergeIntoSet,
  printImport,
  printJSDocs,
} from './common'
import { OpleFunction } from './parsers/functions'
import { tokenize } from './tokenize'
import { OpleSignal } from './parsers/signals'

/**
 * Generate the module that calls `defineBackend`
 * on the frontend.
 */
export function printClientModule(parser: OpleParser, backendUrl: string) {
  const { exportedTypes } = parser
  const referencedTypes = new Set<Node>()

  exportedTypes.forEach(type => {
    const name = getNameNode(type)?.getText()
    if (name && !/^(Signals|CallerMeta)$/.test(name)) {
      referencedTypes.add(type)
    }
  })

  const signals = Object.values(parser.signals)
  const signalTypes = signals.map(signal => {
    mergeIntoSet(referencedTypes, signal.referencedTypes)
    return printSignalType(signal)
  })

  const opleClientId = '@ople/client'
  const imports: Record<string, Set<string>> = {
    [opleClientId]: new Set(['defineBackend', 'OpleProtocol']),
  }
  if (signalTypes.length) {
    imports[opleClientId].add('OpleListener')
  }

  const functions = Object.values(parser.functions)
  const functionTypes = functions.map(fun => {
    mergeIntoSet(referencedTypes, fun.referencedTypes)
    if (fun.isPager) {
      imports[opleClientId].add('OplePage')
    } else if (fun.isCreator) {
      imports[opleClientId].add('makeCreator')
    }
    return fun.signatures.map(sig => {
      const text = printSignature(sig, fun)
      if (text.includes('OpleRefLike')) {
        imports[opleClientId].add('OpleRefLike')
      }
      return text
    })
  })

  const typeNames = new Set<string>()
  const dedupedTypes: Record<string, Node[]> = {}
  const backendModulePath = path.join(parser.root, 'backend/db.ts')

  referencedTypes.forEach(typeNode => {
    const file = typeNode.getSourceFile()
    const filePath = file.getFilePath()
    if (filePath == backendModulePath) {
      return // Ignore generated types
    }
    if (filePath.includes('/node_modules/@ople/init/')) {
      return // Ignore "@ople/init" types
    }

    // Types from internal modules are recursively crawled.
    if (!isExternalModule(file, parser.root)) {
      findReferencedTypes(typeNode, referencedTypes)
    }

    if (!Node.isNamedNode(typeNode)) {
      return
    }

    const name = typeNode.getName()

    // These types don't exist on the client side.
    if (/^Ople(Set|Document)$/.test(name)) {
      return
    }

    // These types are globally declared in ople.init.ts
    // but not on the client-side.
    if (/^Ople(Ref|Time|Date)$/.test(name)) {
      imports[opleClientId].add(name)
      return
    }

    const moduleInfo = parser.dependencies.get(file)
    if (moduleInfo) {
      if (moduleInfo.id == '@ople/backend') {
        return
      }
      const vars = (imports[moduleInfo.id] ??= new Set())
      if (vars.has(name)) {
        return
      }
      if (!typeNames.has(name)) {
        typeNames.add(name)
        vars.add(name)
      }
    } else {
      let typeNodes = dedupedTypes[name]
      if (!typeNodes) {
        typeNodes = dedupedTypes[name] = []
        typeNames.add(name)
      } else if (
        Node.isTypeAliasDeclaration(typeNode) ||
        Node.isTypeAliasDeclaration(typeNodes[0])
      ) {
        warn(typeNode, `Type skipped. Name already taken: "${name}"`)
        return
      }
      typeNodes.push(typeNode)
    }
  })

  const printedTypes = Object.keys(dedupedTypes).map(name => {
    const typeNodes = dedupedTypes[name]
    const lines: string[] = []
    if (typeNodes.length > 1) {
      let postlude = ''
      for (const typeNode of typeNodes) {
        if (Node.isInterfaceDeclaration(typeNode)) {
          lines.length || lines.push(`export interface ${name} {`)
          const sourceFile = typeNode.getSourceFile()
          for (const prop of typeNode.getMembers()) {
            if (sourceFile == prop.getSourceFile()) {
              lines.push(redent(printJSDocs(prop) + prop.getText(), 2))
            }
          }
        } else {
          postlude += (postlude ? '\n' : '') + typeNode.getFullText()
        }
      }
      lines.length && lines.push('}')
      postlude && lines.push(postlude)
    } else {
      lines[0] = typeNodes[0].getFullText()
    }
    return redent(lines.join('\n'), 0).trim()
  })

  return endent`
    /**
     * DO NOT EDIT THIS DIRECTLY!
     * Generated by @ople/codegen
     */
    ${Object.entries(imports).map(printImport).join('\n')}

    interface Functions {
      ${functionTypes.join('\n')}
    }

    interface Signals {
      ${signalTypes.join('\n')}
    }

    declare const console: any

    const backend = defineBackend<Functions, Signals>({
      onError: console.error,
      protocol: OpleProtocol.ws,
      url: "${backendUrl}",
    })

    export default backend

    const { functions, signals } = backend

    ${functions
      .map(({ name, isCreator, signatures }) => {
        let value = `functions.${name}`
        if (isCreator) {
          const [
            props,
          ] = (signatures[0].getDeclaration() as ParameteredNode).getParameters()
          const propTypes = props
            .getType()
            .getProperties()
            .map(prop => prop.getName())
          value = `makeCreator(${value}, "${propTypes}")`
        }
        return `export const ${name} = ${value}`
      })
      .join('\n')}

    ${signals
      .map(({ name }) => `export const ${name} = signals.${name}`)
      .join('\n')}

    ${printedTypes.join('\n\n')}
  `
}

function printSignalType(signal: OpleSignal) {
  const params = signal.node.getParameters()
  const paramsText = params.map(param => param.getText())
  const firstParamType = params[0]?.getTypeNode()
  const targetType =
    firstParamType &&
    tokenize(firstParamType.getText(), tsLang)
      .map(token => (token == 'OpleRef' ? 'OpleRefLike' : token))
      .join('')

  return (
    printJSDocs(signal.node) +
    signal.name +
    `(handler: (${paramsText.join(', ')}) => boolean | void): OpleListener` +
    (targetType
      ? `\n` +
        signal.name +
        `(target: ${targetType}, handler: (${paramsText
          .slice(1)
          .join(', ')}) => boolean | void): OpleListener`
      : ``)
  )
}

function printSignature(sign: Signature, fun: OpleFunction) {
  const decl = sign.getDeclaration()
  if (!Node.isParameteredNode(decl)) {
    throw Error('Signature must be from a parametered node')
  }

  const typeParams = sign.getTypeParameters().map(printType)
  const params = decl.getParameters().map(printParam)
  if (fun.isPager) {
    params.push(`pageOptions?: OplePage.Options`)
  }

  return (
    printJSDocs(decl) +
    fun.name +
    (typeParams.length ? `<${typeParams.join(', ')}>` : ``) +
    `(${params.join(', ')}): ${printReturnType(decl.getReturnType(), fun)}`
  )
}

function printParam(param: ParameterDeclaration) {
  return (
    (param.isRestParameter() ? '...' : '') +
    param.getName() +
    (param.isOptional() ? '?' : '') +
    ': ' +
    printParamType(param.getType())
  )
}

// string literals | identifiers | whitespace | punctuation
const tsLang = /"(.*?)"|[_$\w\d]+|\s+|[.|&?<>{}\[\],:;]/

function printParamType(type: Type) {
  return tokenize(printType(type), tsLang)
    .map(token => (token == 'OpleRef' ? 'OpleRefLike' : token))
    .join('')
}

function printReturnType(type: Type, fun: OpleFunction) {
  let returnType = 'Promise<'

  let token: string,
    tokens = tokenize(printType(type), tsLang)

  if (fun.isPager) {
    if (tokens[0] !== 'OpleSet') {
      warn(fun.node, 'Pager function must return an OpleSet')
      return 'never'
    }
    tokens[0] = 'OplePage'
  }

  for (let i = 0; i < tokens.length; i++) {
    token = tokens[i]
    // Strip "OpleDocument" but leave its type argument.
    if (token == 'OpleDocument') {
      if (tokens[i + 1] == '<') {
        i += 1

        // Find the matching ">" token.
        let depth = 0
        while (tokens[++i] != '>' || depth > 0) {
          returnType += tokens[i]
          if (tokens[i] == '<') {
            depth += 1
          } else if (tokens[i] == '>') {
            depth -= 1
          }
        }
      }
      // Strip the `data` proxy from an `OpleDocument` type.
      if (tokens[i + 2] == '&') {
        // Jump past "{" token.
        i += 4

        // Find the matching "}" token.
        let depth = 0
        while (tokens[++i] != '}' || depth > 0) {
          if (tokens[i] == '{') {
            depth += 1
          } else if (tokens[i] == '}') {
            depth -= 1
          }
        }
      }
    } else {
      returnType += token
    }
  }

  returnType += '>'
  return returnType
}

function printType(type: Type) {
  return type.getText().replace(/\bimport\("[^"]+"\)\./g, '')
}
