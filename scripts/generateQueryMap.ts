import {
  Project,
  Node,
  InterfaceDeclaration,
  MethodSignature,
  Type,
} from 'ts-morph'
import path from 'path'
import fs from 'fs'

const proj = new Project()
const queryModule = proj.addSourceFileAtPath(path.resolve('src/query.ts'))
const arrayModule = proj.addSourceFileAtPath(path.resolve('src/sync/array.ts'))

let stmts = queryModule.getStatements()
const OpleQueries = stmts.find(
  stmt => Node.isInterfaceDeclaration(stmt) && 'OpleQueries' === stmt.getName(),
) as InterfaceDeclaration

stmts = arrayModule.getStatements()
const OpleArray = stmts.find(
  stmt => Node.isInterfaceDeclaration(stmt) && 'OpleArray' === stmt.getName(),
) as InterfaceDeclaration

const queries = OpleQueries.getType().getProperties()
forEachMethod(OpleArray, prop => {
  queries.push(prop.getSymbolOrThrow())
})
const compareStr = (a: string, b: string) => (a > b ? 1 : b > a ? -1 : 0)
queries.sort((a, b) => compareStr(a.getName(), b.getName()))

const snakeCaseExceptions = [
  'containsStr',
  'containsStrRegex',
  'startsWith',
  'endsWith',
  'regexEscape',
  'findStr',
  'findStrRegex',
  'replaceStr',
  'replaceStrRegex',
  'subString',
  'bitAnd',
  'bitNot',
  'bitOr',
  'bitXor',
  'forEach',
]

const specialCases: Record<string, string> = {
  isNonEmpty: 'is_nonempty',
  toLowerCase: 'lowercase',
  toTitleCase: 'titlecase',
  toUpperCase: 'uppercase',
  trimLeft: 'ltrim',
  trimRight: 'rtrim',
}

const generatedLines = [
  `export const queryMap: { [callee: string]: string[] } = {`,
]

const usedNames = new Set<string>()
for (const query of queries) {
  const name = query.getName()
  if (name.startsWith('__@') || usedNames.has(name)) {
    continue
  }
  const props: string[] = []
  props.push(fixCasing(name))
  console.log(name)
  try {
    const [method] = query.getDeclarations() as [MethodSignature]
    for (const param of method.getParameters().slice(1)) {
      props.push(fixCasing(param.getName()))
    }
    generatedLines.push(`  ${name}: ${JSON.stringify(props)},`)
    usedNames.add(name)
  } catch (err: any) {
    console.error(`Failed to parse query "${name}". ${err.stack}`)
  }
}

generatedLines.push(`}\n`)

const OpleFunctions = OpleQueries.getType()
  .getBaseTypes()
  .find(type => 'OpleFunctions' === type.getSymbol()?.getName())!

const getPropertyNames = (type: Type) =>
  type
    .getProperties()
    .map(prop => prop.getName())
    .filter(name => !name.startsWith('__@'))

const queriesByType = {
  global: getPropertyNames(OpleFunctions),
  array: getPropertyNames(OpleArray.getType()),
}

generatedLines.push(
  `export const queriesByType = ${JSON.stringify(queriesByType, null, 2)}\n`,
)

const writeQueries = [
  'create',
  'createCollection',
  'delete',
  'replace',
  'update',
]

generatedLines.push(
  `export const writeQueries = ${JSON.stringify(writeQueries, null, 2)}`,
)

fs.writeFileSync(
  path.resolve('src/queryMap.ts'),
  `// Generated by ${path.relative('src', __filename)}\n\n` +
    generatedLines.join('\n') +
    '\n',
)

function fixCasing(name: string) {
  if (name in specialCases) {
    return specialCases[name]
  }
  if (!snakeCaseExceptions.includes(name)) {
    name = name.replace(/([A-Z])/g, '_$1')
  }
  return name.toLowerCase()
}

function forEachMethod(
  type: InterfaceDeclaration,
  each: (method: MethodSignature) => void,
) {
  type
    .getMembers()
    .forEach(member => Node.isMethodSignature(member) && each(member))
  type
    .getExtends()
    .forEach(
      superType =>
        Node.isInterfaceDeclaration(superType) &&
        forEachMethod(superType, each),
    )
}
