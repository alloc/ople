import { Project, Node, InterfaceDeclaration, MethodSignature } from 'ts-morph'
import path from 'path'
import fs from 'fs'

const proj = new Project()
const queryModule = proj.addSourceFileAtPath(path.resolve('src/query.ts'))

const stmts = queryModule.getStatements()
const OpleQueries = stmts.find(
  (stmt) =>
    Node.isInterfaceDeclaration(stmt) && 'OpleQueries' === stmt.getName(),
) as InterfaceDeclaration

const snakeCaseExceptions = [
  'containsStr',
  'containsStrRegex',
  'startsWith',
  'endsWith',
  'regexEscape',
  'findStr',
  'findStrRegex',
  'replaceStr',
  'replaceStrRegex',
  'subString',
  'bitAnd',
  'bitNot',
  'bitOr',
  'bitXor',
  'forEach',
]

const specialCases: Record<string, string> = {
  isNonEmpty: 'is_nonempty',
  toLowerCase: 'lowercase',
  toTitleCase: 'titlecase',
  toUpperCase: 'uppercase',
  trimLeft: 'ltrim',
  trimRight: 'rtrim',
}

const generatedLines = [`export const queryMap = {`]

for (const query of OpleQueries.getType().getProperties()) {
  const props: string[] = []
  const name = query.getName()
  props.push(fixCasing(name))
  const [method] = query.getDeclarations() as [MethodSignature]
  for (const param of method.getParameters().slice(1)) {
    props.push(fixCasing(param.getName()))
  }
  generatedLines.push(`  ${name}: ${JSON.stringify(props)},`)
}

generatedLines.push(`}\n`)

const OpleFunctions = OpleQueries.getType()
  .getBaseTypes()
  .find((type) => 'OpleFunctions' === type.getSymbol()?.getName())!

generatedLines.push(
  `const globalCallees = ${JSON.stringify(
    OpleFunctions.getProperties().map((prop) => prop.getName()),
    null,
    2,
  )}`,
)

fs.writeFileSync(
  path.resolve('src/queryMap.ts'),
  `// Generated by ${path.relative('src', __filename)}\n` +
    generatedLines.join('\n') +
    '\n',
)

function fixCasing(name: string) {
  if (name in specialCases) {
    return specialCases[name]
  }
  if (!snakeCaseExceptions.includes(name)) {
    name = name.replace(/([A-Z])/g, '_$1')
  }
  return name.toLowerCase()
}
